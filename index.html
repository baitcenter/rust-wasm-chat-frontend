<html>
<head>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
	<style>
		#green-square {
			background: green;
			width: 200px;
			height: 200px;
			text-align: center;
			line-height: 200px;
			color: white;
		}
		#green-square span {
			display: inline-block;
			vertical-align: middle;
		}
	</style>
</head>
<body>
	<script>
		// The `--no-modules`-generated JS from `wasm-bindgen` attempts to use
		// `WebAssembly.instantiateStreaming` to instantiate the wasm module,
		// but this doesn't work with `file://` urls. This example is frequently
		// viewed by simply opening `index.html` in a browser (with a `file://`
		// url), so it would fail if we were to call this function!
		//
		// Work around this for now by deleting the function to ensure that the
		// `no_modules.js` script doesn't have access to it. You won't need this
		// hack when deploying over HTTP.
		delete WebAssembly.instantiateStreaming;
	</script>
	
	<!-- this is the JS generated by the `wasm-bindgen` CLI tool -->
	<script src='./js_hello_world.js'></script>
	
	<script>
		window.addEventListener('load', async () => {
			// the `wasm_bindgen` global is set to the exports of the Rust module
			//
			// here we tell bindgen the path to the wasm file so it can run
			// initialization and return to us a promise when it's done
			// also, we can use 'await' on the returned promise
			await wasm_bindgen('./js_hello_world_bg.wasm');
		});
	</script>
	
	<div id='loading'>
		Loading...
	</div>
	<div id='script' style='display:none'>
		<p>
			The current time is:
			<span id='current-time'>...</span>
		</p>
		
		<div id='green-square'>
			<span>Click me!</span>
		</div>
		<p>
			You've clicked the green square
			<span id='num-clicks'>0</span>
			times
		</p>
	</div>
</body>
</body>
</html>